<html>

<canvas id="framebuffer"></canvas>

<style>
div {
    white-space: pre-wrap;
}
</style>

<div>
W to move forward
S to move backward
A to turn left
D to turn right
Q to strafe left
E to strafe right
F to fire
U to use
</div>

<script>
var Game = {
	stopMain: {},
	curState: {},
	dirty: true,
	keys: {},
};

// typedef struct
// {
//     char	forwardmove;	// *2048 for move
//     char	sidemove;	// *2048 for move
//     short	angleturn;	// <<16 for angle delta
//     short	consistancy;	// checks for net game
//     byte	chatchar;
//     byte	buttons;
// } ticcmd_t;

function GeneratePostBody() {
	if (!Game.curState.byteLength) {
		return;
	}
	var numevents = Object.keys(Game.keys).length;
	var body = new ArrayBuffer(4 + Game.curState.byteLength + 4 + numevents);
	var view = new DataView(body);
	view.setUint32(0,Game.curState.byteLength);

	// I'm sure there's a better way to do this.
	for (i=0;i<Game.curState.byteLength;++i) {
		view.setUint8(i+4, Game.curState[i]);
	}

	view.setUint32(Game.curState.byteLength + 4, numevents);
	let base = 8 + Game.curState.byteLength;
	var index=0;
	for (var key in Game.keys) {
		view.setUint8(base+index,key);
		index++;
	}

	return body;
}

// helper in case we need to download data for inspection
function download(filename, data) {
    var element = document.createElement('a');
    element.setAttribute('href', 'data:binary/octet-stream,' + data);
    element.setAttribute('download', filename);

    element.style.display = 'none';
    document.body.appendChild(element);

    element.click();

    document.body.removeChild(element);
}

document.addEventListener('keydown', (event) => {
  Game.keys[event.keyCode] = 1;
}, false);

document.addEventListener('keyup', (event) => {
	delete Game.keys[event.keyCode];
}, false);

function GetFrame() {
	var xhttp = new XMLHttpRequest();
	xhttp.onload = function(oEvent) {
		var arraybuffer = xhttp.response;
		if (arraybuffer) {
			var byteArray = new Uint8Array(arraybuffer);
			var dv = new DataView(arraybuffer);
			let fb_len = dv.getInt32(0,true); // framebuffer length
			let fb = new Uint8Array(arraybuffer.slice(4));

			const rawcanvas = document.getElementById('framebuffer');
			rawcanvas.width = 960;
			rawcanvas.height = 600;
			const ctx = rawcanvas.getContext('2d');

			var imageData = ctx.getImageData(0, 0, 100, 100);
			var data = new Uint8ClampedArray(4 * 320 * 200);

			var rawoffset=0;
			for (var i = 0; i < data.length; i++) {
				if ((i+1) % 4 == 0) {
					data[i] = 255;
				} else {
					data[i] = fb[rawoffset++];
				}
			}

			var imageData = new ImageData(data, 320,200);
			tempcanvas = document.createElement('canvas');
			tempcanvas.width=320;
			tempcanvas.height=200;
			var tempctx = tempcanvas.getContext('2d');
			tempctx.putImageData(imageData,0,0);

			ctx.scale(3,3);
			ctx.drawImage(tempcanvas,0,0);

			let gs_len = dv.getInt32(4+fb_len,true);
			Game.curState = new Uint8Array(arraybuffer.slice(8+fb_len));
			Game.dirty = true;
		}
	};
	// Access-Control-Allow-Origin	
	xhttp.open("POST", "https://definitely-shining-penguin.edgecompute.app/rawdoomframe", true);
	xhttp.responseType = "arraybuffer";
	var body = GeneratePostBody();
    xhttp.send(body);
}

;(function () {
	function main( tFrame ) {
	Game.stopMain = window.requestAnimationFrame( main );
	var nextTick = Game.lastTick + Game.tickLength;
	var numTicks = 0;

	// If tFrame < nextTick then 0 ticks need to be updated (0 is default for numTicks).
	// If tFrame = nextTick then 1 tick needs to be updated (and so forth).
	// Note: As we mention in summary, you should keep track of how large numTicks is.
	// If it is large, then either your game was asleep, or the machine cannot keep up.
	if (tFrame > nextTick) {
		var timeSinceTick = tFrame - Game.lastTick;
		numTicks = Math.floor( timeSinceTick / Game.tickLength );
	}

	if (Game.dirty)
	{
		GetFrame();
		Game.dirty = false;
	}

	// time

}

	Game.lastTick = performance.now();
	Game.lastRender = Game.lastTick; // Pretend the first draw was on first update.
	Game.tickLength = 100; // This sets your simulation to run at 10Hz (100ms)

	//setInitialState();
	main(performance.now());
})();
</script>
</html>