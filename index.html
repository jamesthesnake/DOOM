<html>

<canvas id="framebuffer"></canvas>

<style>
div {
    white-space: pre-wrap;
}
</style>

<div>
W to move forward
S to move backward
A to turn left
D to turn right
Q to strafe left
E to strafe right
F to fire
U to use
</div>
Player Number <input type="number" id="player_index" value="0" step="1" min="0" max="3" />

<p id="profiling"></p>

<script>
var Game = {
	stopMain: {},
	stateId: 1234,
	startpost: true,
	keys: {},
	frames: {},
	numframes: 0,
	frameIndex: 0,
	lastTick: 0,
	lastRender: 0,

	maxposttimes: 100,
	posttimes: [100],
	numposttimes: 0,
	postindex: 0,
	postfull: false,
};

function AddPostTime(time) {
	if (!Game.postfull) {
		Game.numposttimes++;
	}
	if (Game.numposttimes == Game.maxposttimes) {
		Game.postfull = true;
	}
	Game.postindex = (Game.postindex + 1) % Game.numposttimes;
	Game.posttimes[Game.postindex] = time;
}

function GetAveragePostTime() {
	var total = 0;
	for (i=0;i<Game.numposttimes;++i) {
		total += Game.posttimes[i];
	}
	return total / Game.numposttimes;
}

// typedef struct
// {
//     char	forwardmove;	// *2048 for move
//     char	sidemove;	// *2048 for move
//     short	angleturn;	// <<16 for angle delta
//     short	consistancy;	// checks for net game
//     byte	chatchar;
//     byte	buttons;
// } ticcmd_t;

function GeneratePostBody() {
	if (Game.stateId == 0) {
		return;
	}
	var numevents = Object.keys(Game.keys).length;
	var body = new ArrayBuffer(12 + numevents + 4);
	var view = new DataView(body);
	view.setUint32(0,Game.stateId);

	var player_index = document.getElementById("player_index").value;
	view.setUint32(4, player_index);
	view.setUint32(8, numevents);
	var index=0;
	for (var key in Game.keys) {
		view.setUint8(12+index,key);
		index++;
	}
//	var num_requested_frames = GetAveragePostTime() / 50;
	var num_requested_frames = 1; // adaptive frame interpolation isn't helping a lot yet.
	view.setUint32(12+index,num_requested_frames);

	return body;
}

// helper in case we need to download data for inspection
function download(filename, data) {
    var element = document.createElement('a');
    element.setAttribute('href', 'data:binary/octet-stream,' + data);
    element.setAttribute('download', filename);

    element.style.display = 'none';
    document.body.appendChild(element);

    element.click();

    document.body.removeChild(element);
}

document.addEventListener('keydown', (event) => {
  Game.keys[event.keyCode] = 1;
}, false);

document.addEventListener('keyup', (event) => {
	delete Game.keys[event.keyCode];
}, false);

function RenderFrame(index) {
	index = 0;
	const rawcanvas = document.getElementById('framebuffer');
	rawcanvas.width = 960;
	rawcanvas.height = 600;
	const ctx = rawcanvas.getContext('2d');

	var imageData = ctx.getImageData(0, 0, 100, 100);
	var data = new Uint8ClampedArray(4 * 320 * 200);

	var palette = new Uint8ClampedArray(256*3);
	for (var i = 0; i < 256 * 3; ++i) {
		palette[i] = Game.frames[index][i];
	}
	//for (var i = 256*3; i < fb.length; i += 4) {
	fb_index = 256*3;
	for (var i = 0; i < data.length; i += 4) {
		data[i] = palette[Game.frames[index][fb_index]*3];
		data[i+1] = palette[Game.frames[index][fb_index]*3+1];
		data[i+2] = palette[Game.frames[index][fb_index]*3+2];
		data[i+3] = 255;
		fb_index++;
	}

	var imageData = new ImageData(data, 320,200);
	tempcanvas = document.createElement('canvas');
	tempcanvas.width=320;
	tempcanvas.height=200;
	var tempctx = tempcanvas.getContext('2d');
	tempctx.putImageData(imageData,0,0);

	ctx.scale(3,3);
	ctx.drawImage(tempcanvas,0,0);
	Game.lastRender = performance.now();
}

function GetFrame() {
	var xhttp = new XMLHttpRequest();
	var startpost = performance.now();
	xhttp.onload = function(oEvent) {
		var posttime = performance.now() - startpost;
		AddPostTime(posttime);
		var arraybuffer = xhttp.response;
		if (arraybuffer) {
			var byteArray = new Uint8Array(arraybuffer);
			var dv = new DataView(arraybuffer);

			let num_frames = dv.getInt32(0, true); // number of frames
			let frame_len = 320*200 + 768;

			for (i=0;i<num_frames;++i) {
				let fb = new Uint8Array(arraybuffer.slice(4+i*frame_len));
				Game.frames[i] = fb;
			}

			Game.numframes = num_frames;
			Game.frameIndex = 0;

			Game.stateId = dv.getInt32(4+num_frames*frame_len,true);
			Game.startpost = true;
		}
	};
	// Access-Control-Allow-Origin	
	xhttp.open("POST", "https://especially-cunning-bat.edgecompute.app/zipdoomframe", true);
	xhttp.responseType = "arraybuffer";
	var body = GeneratePostBody();
    xhttp.send(body);
}

;(function () {
	function main( tFrame ) {
	Game.stopMain = window.requestAnimationFrame( main );
	var delta = tFrame-Game.lastTick;
	Game.lastTick = tFrame;

	if (Game.numframes > 0) {
		if (performance.now() - Game.lastRender > GetAveragePostTime() / Game.numframes) {
			// var frametime = performance.now() - Game.lastRender;
			// document.getElementById('profiling').innerHTML = "Frametime: " + frametime;
			RenderFrame(Game.frameIndex);
			if (Game.frameIndex < Game.numframes-1)
				Game.frameIndex++;
		}
	}

	if (Game.startpost)
	{
		GetFrame();
		Game.startpost = false;
	}
}

	Game.lastTick = performance.now();
	main(performance.now());
})();
</script>
</html>