<html>

<canvas id="framebuffer"></canvas>

<style>
div {
    white-space: pre-wrap;
}
</style>

<div>
W to move forward
S to move backward
A to turn left
D to turn right
Q to strafe left
E to strafe right
F to fire
U to use
</div>

<script>
var Game = {
	stopMain: {},
	curState: {},
	startpost: true,
	keys: {},
	frames: {},
	numframes: 0,
	frameIndex: 0,
	lastTick: 0,
	lastRender: 0,

	maxposttimes: 100,
	posttimes: [100],
	numposttimes: 0,
	postindex: 0,
	postfull: false,
};

function AddPostTime(time) {
	if (!Game.postfull) {
		Game.numposttimes++;
	}
	if (Game.numposttimes == Game.maxposttimes) {
		Game.postfull = true;
	}
	Game.postindex = (Game.postindex + 1) % Game.numposttimes;
	Game.posttimes[Game.postindex] = time;
}

function GetAveragePostTime() {
	var total = 0;
	for (i=0;i<Game.numposttimes;++i) {
		total += Game.posttimes[i];
	}
	return total / Game.numposttimes;
}

// typedef struct
// {
//     char	forwardmove;	// *2048 for move
//     char	sidemove;	// *2048 for move
//     short	angleturn;	// <<16 for angle delta
//     short	consistancy;	// checks for net game
//     byte	chatchar;
//     byte	buttons;
// } ticcmd_t;

function GeneratePostBody() {
	if (!Game.curState.byteLength) {
		return;
	}
	var numevents = Object.keys(Game.keys).length;
	var body = new ArrayBuffer(4 + Game.curState.byteLength + 4 + numevents);
	var view = new DataView(body);
	view.setUint32(0,Game.curState.byteLength);

	// I'm sure there's a better way to do this.
	for (i=0;i<Game.curState.byteLength;++i) {
		view.setUint8(i+4, Game.curState[i]);
	}

	view.setUint32(Game.curState.byteLength + 4, numevents);
	let base = 8 + Game.curState.byteLength;
	var index=0;
	for (var key in Game.keys) {
		view.setUint8(base+index,key);
		index++;
	}

	return body;
}

// helper in case we need to download data for inspection
function download(filename, data) {
    var element = document.createElement('a');
    element.setAttribute('href', 'data:binary/octet-stream,' + data);
    element.setAttribute('download', filename);

    element.style.display = 'none';
    document.body.appendChild(element);

    element.click();

    document.body.removeChild(element);
}

document.addEventListener('keydown', (event) => {
  Game.keys[event.keyCode] = 1;
}, false);

document.addEventListener('keyup', (event) => {
	delete Game.keys[event.keyCode];
}, false);

function RenderFrame(index) {
	const rawcanvas = document.getElementById('framebuffer');
	rawcanvas.width = 960;
	rawcanvas.height = 600;
	const ctx = rawcanvas.getContext('2d');

	var imageData = ctx.getImageData(0, 0, 100, 100);
	var data = new Uint8ClampedArray(4 * 320 * 200);

	var palette = new Uint8ClampedArray(256*3);
	for (var i = 0; i < 256 * 3; ++i) {
		palette[i] = Game.frames[index][i];
	}
	//for (var i = 256*3; i < fb.length; i += 4) {
	fb_index = 256*3;
	for (var i = 0; i < data.length; i += 4) {
		data[i] = palette[Game.frames[index][fb_index]*3];
		data[i+1] = palette[Game.frames[index][fb_index]*3+1];
		data[i+2] = palette[Game.frames[index][fb_index]*3+2];
		data[i+3] = 255;
		fb_index++;
	}

	var imageData = new ImageData(data, 320,200);
	tempcanvas = document.createElement('canvas');
	tempcanvas.width=320;
	tempcanvas.height=200;
	var tempctx = tempcanvas.getContext('2d');
	tempctx.putImageData(imageData,0,0);

	ctx.scale(3,3);
	ctx.drawImage(tempcanvas,0,0);
	Game.lastRender = performance.now();
}

function GetFrame() {
	var xhttp = new XMLHttpRequest();
	var startpost = performance.now();
	xhttp.onload = function(oEvent) {
		var posttime = performance.now() - startpost;
		AddPostTime(posttime);
		var arraybuffer = xhttp.response;
		if (arraybuffer) {
			var byteArray = new Uint8Array(arraybuffer);
			var dv = new DataView(arraybuffer);

			let fb_len1 = dv.getInt32(0,true); // framebuffer length
			let fb1 = new Uint8Array(arraybuffer.slice(4));
			Game.frames[0] = fb1;

			let fb_len2 = dv.getInt32(4+fb_len1,true); // framebuffer length
			let fb2 = new Uint8Array(arraybuffer.slice(8+fb_len1));

			Game.frames[1] = fb2;

			let fb_len3 = dv.getInt32(8+fb_len1+fb_len2,true); // framebuffer length
			let fb3 = new Uint8Array(arraybuffer.slice(12+fb_len1+fb_len2));

			Game.frames[2] = fb3;

			Game.numframes = 3;
			Game.frameIndex = 0;

			let gs_len = dv.getInt32(12+fb_len1+fb_len2+fb_len3,true);
			Game.curState = new Uint8Array(arraybuffer.slice(16+fb_len1+fb_len2+fb_len3));
			Game.startpost = true;
		}
	};
	// Access-Control-Allow-Origin	
	xhttp.open("POST", "https://definitely-shining-penguin.edgecompute.app/zipdoomframe", true);
	xhttp.responseType = "arraybuffer";
	var body = GeneratePostBody();
    xhttp.send(body);
}

;(function () {
	function main( tFrame ) {
	Game.stopMain = window.requestAnimationFrame( main );
	var delta = tFrame-Game.lastTick;
	Game.lastTick = tFrame;
	console.log("Average: ", GetAveragePostTime());

	if (Game.numframes > 0) {
		if (performance.now() - Game.lastRender > GetAveragePostTime() / Game.numframes) {
			console.log("FPS ", performance.now() - Game.lastRender);
			RenderFrame(Game.frameIndex);
			if (Game.frameIndex < Game.numframes-1)
				Game.frameIndex++;
		}
	}

	if (Game.startpost)
	{
		GetFrame();
		Game.startpost = false;
	}
}

	Game.lastTick = performance.now();
	main(performance.now());
})();
</script>
</html>