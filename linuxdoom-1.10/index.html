"<html>\n"
"\n"
"<canvas id=\"framebuffer\"></canvas>\n"
"\n"
"<style>\n"
"div {\n"
"    white-space: pre-wrap;\n"
"}\n"
"</style>\n"
"\n"
"<div>\n"
"W to move forward\n"
"S to move backward\n"
"A to turn left\n"
"D to turn right\n"
"Q to strafe left\n"
"E to strafe right\n"
"F to fire\n"
"U to use\n"
"</div>\n"
"\n"
"<script>\n"
"var Game = {\n"
"	stopMain: {},\n"
"	curState: {},\n"
"	dirty: true,\n"
"	keys: {},\n"
"};\n"
"\n"
"// typedef struct\n"
"// {\n"
"//     char	forwardmove;	// *2048 for move\n"
"//     char	sidemove;	// *2048 for move\n"
"//     short	angleturn;	// <<16 for angle delta\n"
"//     short	consistancy;	// checks for net game\n"
"//     byte	chatchar;\n"
"//     byte	buttons;\n"
"// } ticcmd_t;\n"
"\n"
"function GeneratePostBody() {\n"
"	if (!Game.curState.byteLength) {\n"
"		return;\n"
"	}\n"
"	var numevents = Object.keys(Game.keys).length;\n"
"	var body = new ArrayBuffer(4 + Game.curState.byteLength + 4 + numevents);\n"
"	var view = new DataView(body);\n"
"	view.setUint32(0,Game.curState.byteLength);\n"
"\n"
"	// I'm sure there's a better way to do this.\n"
"	for (i=0;i<Game.curState.byteLength;++i) {\n"
"		view.setUint8(i+4, Game.curState[i]);\n"
"	}\n"
"\n"
"	view.setUint32(Game.curState.byteLength + 4, numevents);\n"
"	let base = 8 + Game.curState.byteLength;\n"
"	var index=0;\n"
"	for (var key in Game.keys) {\n"
"		view.setUint8(base+index,key);\n"
"		index++;\n"
"	}\n"
"\n"
"	return body;\n"
"}\n"
"\n"
"// helper in case we need to download data for inspection\n"
"function download(filename, data) {\n"
"    var element = document.createElement('a');\n"
"    element.setAttribute('href', 'data:binary/octet-stream,' + data);\n"
"    element.setAttribute('download', filename);\n"
"\n"
"    element.style.display = 'none';\n"
"    document.body.appendChild(element);\n"
"\n"
"    element.click();\n"
"\n"
"    document.body.removeChild(element);\n"
"}\n"
"\n"
"document.addEventListener('keydown', (event) => {\n"
"  Game.keys[event.keyCode] = 1;\n"
"}, false);\n"
"\n"
"document.addEventListener('keyup', (event) => {\n"
"	delete Game.keys[event.keyCode];\n"
"}, false);\n"
"\n"
"function GetFrame() {\n"
"	var xhttp = new XMLHttpRequest();\n"
"	xhttp.onload = function(oEvent) {\n"
"		var arraybuffer = xhttp.response;\n"
"		if (arraybuffer) {\n"
"			var byteArray = new Uint8Array(arraybuffer);\n"
"			var dv = new DataView(arraybuffer);\n"
"			let fb_len = dv.getInt32(0,true); // framebuffer length\n"
"			let fb = new Uint8Array(arraybuffer.slice(4));\n"
"\n"
"			const rawcanvas = document.getElementById('framebuffer');\n"
"			rawcanvas.width = 960;\n"
"			rawcanvas.height = 600;\n"
"			const ctx = rawcanvas.getContext('2d');\n"
"\n"
"			var imageData = ctx.getImageData(0, 0, 100, 100);\n"
"			var data = new Uint8ClampedArray(4 * 320 * 200);\n"
"\n"
"			var rawoffset=0;\n"
"			for (var i = 0; i < data.length; i++) {\n"
"				if ((i+1) % 4 == 0) {\n"
"					data[i] = 255;\n"
"				} else {\n"
"					data[i] = fb[rawoffset++];\n"
"				}\n"
"			}\n"
"\n"
"			var imageData = new ImageData(data, 320,200);\n"
"			tempcanvas = document.createElement('canvas');\n"
"			tempcanvas.width=320;\n"
"			tempcanvas.height=200;\n"
"			var tempctx = tempcanvas.getContext('2d');\n"
"			tempctx.putImageData(imageData,0,0);\n"
"\n"
"			ctx.scale(3,3);\n"
"			ctx.drawImage(tempcanvas,0,0);\n"
"\n"
"			let gs_len = dv.getInt32(4+fb_len,true);\n"
"			Game.curState = new Uint8Array(arraybuffer.slice(8+fb_len));\n"
"			Game.dirty = true;\n"
"		}\n"
"	};\n"
"	// Access-Control-Allow-Origin	\n"
"	xhttp.open(\"POST\", \"https://definitely-shining-penguin.edgecompute.app/rawdoomframe\", true);\n"
"	xhttp.responseType = \"arraybuffer\";\n"
"	var body = GeneratePostBody();\n"
"    xhttp.send(body);\n"
"}\n"
"\n"
";(function () {\n"
"	function main( tFrame ) {\n"
"	Game.stopMain = window.requestAnimationFrame( main );\n"
"	var nextTick = Game.lastTick + Game.tickLength;\n"
"	var numTicks = 0;\n"
"\n"
"	// If tFrame < nextTick then 0 ticks need to be updated (0 is default for numTicks).\n"
"	// If tFrame = nextTick then 1 tick needs to be updated (and so forth).\n"
"	// Note: As we mention in summary, you should keep track of how large numTicks is.\n"
"	// If it is large, then either your game was asleep, or the machine cannot keep up.\n"
"	if (tFrame > nextTick) {\n"
"		var timeSinceTick = tFrame - Game.lastTick;\n"
"		numTicks = Math.floor( timeSinceTick / Game.tickLength );\n"
"	}\n"
"\n"
"	if (Game.dirty)\n"
"	{\n"
"		GetFrame();\n"
"		Game.dirty = false;\n"
"	}\n"
"\n"
"	// time\n"
"\n"
"}\n"
"\n"
"	Game.lastTick = performance.now();\n"
"	Game.lastRender = Game.lastTick; // Pretend the first draw was on first update.\n"
"	Game.tickLength = 100; // This sets your simulation to run at 10Hz (100ms)\n"
"\n"
"	//setInitialState();\n"
"	main(performance.now());\n"
"})();\n"
"</script>\n"
"</html\n"
